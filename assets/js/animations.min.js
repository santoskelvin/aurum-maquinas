/**
 * Animações leves usando Intersection Observer API
 * Substitui GSAP com solução nativa e performática
 */
(function() {
  'use strict';

  // Respeitar preferência de movimento reduzido
  if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
    return;
  }

  // Configuração do Intersection Observer
  const observerOptions = {
    root: null,
    rootMargin: '0px 0px -10% 0px', // Anima quando o elemento está 10% visível
    threshold: 0.1
  };

  // Callback do Observer
  const observerCallback = (entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const target = entry.target;
        
        // Adicionar classe de animação
        if (target.classList.contains('fade-up')) {
          target.classList.add('animate');
        } else if (target.classList.contains('fade-in')) {
          target.classList.add('animate');
        } else if (target.classList.contains('slide-left')) {
          target.classList.add('animate');
        } else if (target.classList.contains('slide-right')) {
          target.classList.add('animate');
        } else if (target.classList.contains('hero-animate-item')) {
          target.classList.add('visible');
        } else {
          target.classList.add('animate');
        }
        
        // Parar de observar após animar (performance)
        observer.unobserve(target);
      }
    });
  };

  // Criar observer
  const observer = new IntersectionObserver(observerCallback, observerOptions);

  // Função para inicializar animações
  function initAnimations() {
    // Elementos do Hero
    const heroItems = document.querySelectorAll('.hero-animate-item');
    heroItems.forEach(item => observer.observe(item));

    // Seções com fade-up
    const fadeUpElements = document.querySelectorAll('.fade-up');
    fadeUpElements.forEach(el => observer.observe(el));

    // Elementos com fade-in
    const fadeInElements = document.querySelectorAll('.fade-in');
    fadeInElements.forEach(el => observer.observe(el));

    // Elementos com slide
    const slideLeftElements = document.querySelectorAll('.slide-left');
    slideLeftElements.forEach(el => observer.observe(el));

    const slideRightElements = document.querySelectorAll('.slide-right');
    slideRightElements.forEach(el => observer.observe(el));

    // Cards e elementos de grid
    const cards = document.querySelectorAll('.chart-card, .plano-card, .aurum-card, .passo-card');
    cards.forEach(card => observer.observe(card));

    // Steps
    const steps = document.querySelectorAll('.step-item');
    steps.forEach(step => observer.observe(step));

    // FAQ Items
    const faqItems = document.querySelectorAll('.faq-item');
    faqItems.forEach(item => observer.observe(item));

    // Animação dos contadores do Hero
    animateHeroCounters();
  }

  // Animação dos números do Hero (contador)
  function animateHeroCounters() {
    const counters = document.querySelectorAll('.hero-metric-value[data-target]');
    
    counters.forEach(counter => {
      const target = parseInt(counter.getAttribute('data-target'));
      const prefix = counter.getAttribute('data-prefix') || '';
      const suffix = counter.getAttribute('data-suffix') || '';
      const duration = 2000; // 2 segundos
      const steps = 60;
      const increment = target / steps;
      const stepDuration = duration / steps;
      
      let current = 0;
      
      // Observer específico para contadores
      const counterObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const timer = setInterval(() => {
              current += increment;
              
              if (current >= target) {
                current = target;
                clearInterval(timer);
              }
              
              // Formatar número
              let displayValue = Math.floor(current).toLocaleString('pt-BR');
              counter.textContent = prefix + displayValue + suffix;
            }, stepDuration);
            
            counterObserver.unobserve(entry.target);
          }
        });
      }, { threshold: 0.5 });
      
      counterObserver.observe(counter);
    });
  }

  // Inicializar quando o DOM estiver pronto
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAnimations);
  } else {
    initAnimations();
  }

  // Re-observar elementos dinâmicos (se necessário)
  window.reObserveAnimations = function() {
    initAnimations();
  };

})();
